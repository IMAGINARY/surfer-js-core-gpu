function e(e){return e&&e.__esModule?e.default:e}CindyJS;function n(e){return new Array(e+1).fill(0).map(((n,i)=>i/e))}function i(e,n){return(function(e,n){return Math.cos((2*e-1)/(2*n)*Math.PI)}(e,n)+1)/2}function t(e){return new Array(e+1).fill(0).map(((e,n)=>n+1)).map((n=>i(n,e+1)))}class o{minDegree;maxDegree;nodeGenerator;constructor(e=o.nodeGeneratorEquidistant(),n=Number.POSITIVE_INFINITY,i=0){this.nodeGenerator=e,this.minDegree=Math.max(0,i),this.maxDegree=Math.max(this.minDegree,n)}getMinDegree(){return this.minDegree}getMaxDegree(){return this.maxDegree}generateNodes(e){const n=Math.max(this.minDegree,Math.min(e,this.maxDegree)),i=this.nodeGenerator(n).map((e=>Math.max(0,Math.min(e,1))));for(i.length=Math.min(i.length);i.length<n+1;)i.push(1);return i}static nodeGeneratorEquidistant(){return n}static nodeGeneratorChebyshev(){return t}}class a{lights;constructor(e=[{direction:[0,0,-1],color:[.3,.5,1],gamma:1,cameraSpace:!0},{direction:[0,0,-1],color:[.5,1,1],gamma:10,cameraSpace:!0},{direction:[0,0,1],color:[1,.2,.1],gamma:1,cameraSpace:!0},{direction:[0,0,1],color:[1,1,.5],gamma:10,cameraSpace:!0},{direction:[-10,10,-2],color:[.63,.72,.27],gamma:5,cameraSpace:!1},{direction:[10,-8,3],color:[.54,.09,.54],gamma:5,cameraSpace:!1}]){this.lights=e}getLights(){return this.lights}}const r=`${e('//initialize some variables\nmat = [\n    [0.3513, -0.4908, -0.7973],\n    [-0.8171, -0.5765, -0.0051],\n    [-0.4571, 0.6533, -0.6036]\n];\nsx = mouse().x;\nsy = mouse().y;\ndragging = false;\nN = 5; // degree of the surface; will be overwritten\nli = []; // nodes for interpolation; will be overwritten\nzoom = 2.2;\na = 0.3;\nalpha = .7;\naspectRatio = 1.0;\nhasTwoSides = true;\n\n//we stand at position mat*(0, 0, -2.2) and watch to (0,0,0).\n//ray(pixel, t) is the point in R^3 that lies at position t the ray behind the pixel at location pixel(vec2)\n//t=0 is corresponds to points within the interesting area near (0,0,0)\nray(pixel, t) := mat * ((t+2.2) * (pixel.x, pixel.y, 1) + (0, 0, -2.2));\n\n//sphere with radius 1 for clipping\nS(r) := (r * r - 1);\n\n//fun is the user defined trivariate polynomial\nfun(x, y, z) := x^2 + 1;\n\n//F takes vec3 instead of 3 variables\nF(p) := (p=p/zoom;fun(p.x, p.y, p.z));\n    \n//casteljau algorithm to evaluate and subdivide polynomials in Bernstein form.\n//poly is a vector containing the coefficients, i.e. p(x) = sum(0..N, i, poly_(i+1) * b_(i,N)(x)) where b_(i,N)(x) = choose(N, i)*x^i*(1-x)^(N-1)\ncasteljau(poly, x) := (\n  regional(alpha, beta);\n  alpha = 1-x;\n  beta = x;\n  forall(0..N, k,\n    repeat(N-k,\n      poly_# = alpha*poly_# + beta*poly_(#+1);\n    );\n  );\n  poly //the bernstein-coefficients of the polynomial in the interval [x,1]\n);\n\n//evaluates a polynomial, represented as vector of coefficients in bernstein-form\neval(poly, x) := casteljau(poly, x)_1;\n\nInfinity = 1e100000;\n\n//this function has to be called whenever fun changes\ninit() := (\n  dx = .05; dy =.02;\n  diff(fun(x,y,z), x, dxF(x,y,z) := #);\n  diff(fun(x,y,z), y, dyF(x,y,z) := #);\n  diff(fun(x,y,z), z, dzF(x,y,z) := #);\n\n    N = degree(fun(x,y,z), x, y, z);\n    if(N == -1, N=Infinity);\n    print("Surface degree: " + text(N));\n    newLi = getInterpolationNodes(N);\n    N = length(newLi) - 1;\n    print("Degree of interpolating polynomial: " + text(N));\n    print("Interpolation nodes: " + text(newLi));\n\n    if(newLi != li,\n      li = newLi;\n      //A is the matrix of the linear map that evaluates a polynomial in bernstein-form at the interpolation nodes\n      A = apply(li, node,\n        //the i-th column contains the values of the (i,N) bernstein polynomial evaluated at the interpolation nodes\n        apply(0..N, i, eval(\n          apply(0..N, if(#==i,1,0)), // e_i = [0,0,0,1,0,0]\n          node //evaluate  b_(i,N)(node)\n        )) \n      );\n      \n      B = (inverse(A)); //B interpolates polynomials (in Bernstein basis), given the values [p(li_1), p(li_2), ...]\n    )\n);\n\n//B3 is a matrix that interpolates quadratic polynomials (in monomial basis), given the values [p(-2), p(0), p(2)]\nB3 = inverse(apply([-2, 0, 2], c, apply(0 .. 2, i, c ^ i))); \n\n//use symbolic differentation function\ndF(p) := (p=p/zoom; (\n    dxF(p.x,p.y,p.z),\n    dyF(p.x,p.y,p.z),\n    dzF(p.x,p.y,p.z)\n));\n\n//update the color color for the pixel at position pixel assuming that the surface has been intersected at ray(pixel, dst)\n//because of the alpha-transparency updatecolor should be called for the intersections with large dst first\n// color is a float[4] representing RGBA with premultiplied alpha\nupdatecolor(pixel, dst, color) := (\n  regional(x, normal, dr);\n  x = ray(pixel, dst); //the intersection point in R^3\n  color = (1 - alpha) * color;\n        \n  normal = dF(x);\n  normal = normal / |normal|;\n\n  if(hasTwoSides == false,\n    dr = ray(pixel,1)-ray(pixel,0);\n    if(normal*dr>0, normal=-normal);\n  );\n\n  colorHit = (0., 0., 0.);\n  forall(1..length(lightdirs),\n    //illuminate if the normal and lightdir point in the same direction\n    illumination = max(0, (lightdirs_# / abs(lightdirs_#)) * normal);\n    colorHit = colorHit + alpha * (illumination ^ gamma_#) * colors_#;\n  );\n  color = color + (colorHit_1, colorHit_2, colorHit_3, alpha);\n);\n\n\nnsign(pixel, a, b) := ( //Descartes rule of sign for the interval (a,b)\n  //obtain the coefficients in bernstein basis of F along the ray in interval (a,b) by interpolation within this interval\n  poly = B * apply(li,\n    F(ray(pixel, a+#*(b-a))) //evaluate F(ray(pixel, ·)) along Chebyshev nodes for (a,b)\n  );\n  //count the number of sign changes\n  ans = 0;\n  //last = poly_1;\n  forall(2..(N+1), k,\n    //if(last == 0, last = poly_k;); this (almost) never happens\n    if(min(poly_(k-1), poly_k) <= 0 & 0 <= max(poly_(k-1), poly_k), //sign switch; avoid products due numerics\n      ans = ans + 1;\n    );\n  );\n  ans //return value   \n);\n\n\n//bisect F(ray(pixel, ·)) in [x0, x1] assuming that F(ray(pixel, x0)) and F(ray(pixel, x1)) have opposite signs\nbisectf(pixel, x0, x1) := (\n    regional(v0, v1, m, vm);\n    v0 = F(ray(pixel, x0));\n    v1 = F(ray(pixel, x1));\n    repeat(11,\n        m = (x0 + x1) / 2; vm = F(ray(pixel, m));\n        if (min(v0,vm) <= 0 & 0 <= max(v0, vm), //sgn(v0)!=sgn(vm); avoid products due numerics\n            (x1 = m; v1 = vm;),\n            (x0 = m; v0 = vm;)\n        );\n    );\n    m //return value   \n);\n\n//id encodes a node in a binary tree using heap-indices\n//1 is root node and node v has children 2*v and 2*v+1\n//computes s=2^depth of a node id: Compute floor(log_2(id));\n//purpose: id corresponds interval [id-s,id+1-s]/s\ngets(id) := (\n  s = 1;\n  repeat(15,\n    if(2*s<=id,\n      s = 2*s;\n    )\n  );\n  s //return value\n);\n\n//determines the next node in the binary tree that would be visited by a regular in DFS\n//if the children of id are not supposed to be visited\n//In interval logic: finds the biggest unvisited interval directly right of the interval of id.\nnext(id) := (\n  id = id+1;\n  //now: remove zeros from right (in binary representation) while(id&1) id=id>>1;\n  repeat(15,\n    if(mod(id,2)==0, \n      id = floor(id/2);\n    )\n  );\n  if(id==1, 0, id) //return value - id 0 means we stop our DFS\n);\n\n//what color should be given to pixel with pixel-coordinate pixel (vec2)\n// color is a float[4] representing RGBA with premultiplied alpha\ncomputeColor(pixel, l, u, color) := (\n  regional(a, b);\n  //traverse binary tree (DFS) using heap-indices\n  //1 is root node and node v has children 2*v and 2*v+1\n  id = 1; \n  //maximum number of steps\n  repeat(min(N*8,80),\n    //id=0 means we are done; do only a DFS-step if we are not finished yet\n    if(id>0,\n      s = gets(id); //s = floor(log_2(id))\n      \n      //the intervals [a,b] are chossen such that (id in binary notation)\n      //id = 1   => [a,b]=[l,u]\n      //id = 10  => [a,b]=[l,(u+l)/2]\n      //id = 101 => [a,b]=[l,(u+3*l)/4]\n      //id = 11  => [a,b]=[(u+l)/2,u]\n      //...\n      if(findAllRoots,(\n        // back to front\n        a = u - (u-l)*((id+1)/s-1);\n        b = u - (u-l)*((id+0)/s-1);\n      ),(\n        // front to back\n        a = l + (u-l)*((id+0)/s-1);\n        b = l + (u-l)*((id+1)/s-1);\n      ));\n\n      //how many sign changes has F(ray(pixel, ·)) in (a,b)?\n      cnt = nsign(pixel, a, b);\n      if(cnt == 1, // in this case we found a root (or it is likely to have a multiple root)\n        //=>colorize and break DFS\n        color = updatecolor(pixel, bisectf(pixel, a, b), color);\n        if(findAllRoots,\n          id = next(id), // break DFS\n          id = 0 // stop searching\n        ),\n      if(cnt == 0, //there is no root\n        id = next(id), //break DFS\n        \n        //otherwise cnt>=2: there are cnt - 2*k roots.\n        id = 2*id;  //visit first child within DFS\n      )\n  );  \n  ));\n  color\n);\n')}; csInitDone();`,s=new Map;CindyJS.registerPlugin(1,"surfer-js-core-gpu",(e=>{const n=e.instance,i=s.get(n);if(void 0===i)throw new Error("Unknown CindyJS instance.");const{onInit:t}=i;e.defineFunction("csInitDone",0,(()=>t(e)))}));class l{api;cdy;element;canvas;intersectionAlgorithm;illumnimationModel;expression="x^2 - 1";twoSided=!0;alpha=1;zoom=1;parameters={};static IntersectionAlgorithms={PolynomialInterpolation:o};static IlluminationModels={Montag:a};constructor(e,n,i){this.api=e,this.cdy=e.instance,this.element=n,this.canvas=i;const t=o.nodeGeneratorChebyshev();this.intersectionAlgorithm=new o(t,7),this.illumnimationModel=new a,this.defineCindyScriptFunctions(),this.setIntersectionAlgorithm(this.intersectionAlgorithm),this.setIlluminationModel(this.illumnimationModel),this.setExpression(this.expression),this.setTwoSided(this.twoSided),this.setAlpha(this.alpha),this.setZoom(this.zoom),Object.entries(this.parameters).forEach((([e,n])=>this.setParameter(e,n)))}defineCindyScriptFunctions(){const e=e=>({ctype:"list",value:e.map((e=>({ctype:"number",value:{real:e,imag:0}})))}),n=n=>({ctype:"list",value:n.map((n=>e(n)))});(()=>{this.api.defineFunction("getInterpolationNodes",1,(n=>{const i=this.api.evaluateAndVal(n[0]).value.real,t=this.getIntersectionAlgorithm().generateNodes(i);return e(t)}))})(),(()=>{this.api.defineFunction("getCameraSpaceLightDirections",0,(()=>n(this.getIlluminationModel().getLights().filter((({cameraSpace:e})=>e)).map((({direction:e})=>e))))),this.api.defineFunction("getSurfaceSpaceLightDirections",0,(()=>n(this.getIlluminationModel().getLights().filter((({cameraSpace:e})=>!e)).map((({direction:e})=>e))))),this.api.defineFunction("getLightColors",0,(()=>n(this.getIlluminationModel().getLights().map((({color:e})=>e))))),this.api.defineFunction("getLightGammas",0,(()=>e(this.getIlluminationModel().getLights().map((({gamma:e})=>e)))))})()}getIntersectionAlgorithm(){return this.intersectionAlgorithm}getIlluminationModel(){return this.illumnimationModel}getExpression(){return this.expression}getTwoSided(){return this.twoSided}getAlpha(){return this.alpha}getZoom(){return this.zoom}getParameter(e){return this.parameters[e]}getParameters(){return{...this.parameters}}getParameterNames(){return Object.keys(this.parameters)}setExpression(e){return this.expression=e,this.cdy.evokeCS(`fun(x,y,z) := (${e}); init();`),this}setTwoSided(e){return this.twoSided=e,this.cdy.evokeCS(`hasTwoSides = (${e?"true":"false"});`),this}setAlpha(e){return this.alpha=e,this.cdy.evokeCS(`alpha = (${e});`),this}setZoom(e){return this.zoom=e,this.cdy.evokeCS(`zoom = (${e});`),this}setParameter(e,n){return this.parameters[e]=n,this.cdy.evokeCS(`${e} = (${n});`),this}setIntersectionAlgorithm(e){this.intersectionAlgorithm=e,this.cdy.evokeCS("init();")}setIlluminationModel(e){this.illumnimationModel=e,this.cdy.evokeCS("init();")}static async create(n,i=256,t=256){const o=n.ownerDocument.createElement("canvas");o.width=i,o.height=t,n.appendChild(o);const a=CindyJS.newInstance({scripts:{init:r,draw:e("gsave();\nif(aspectRatio > 1.0,scale(1.0/aspectRatio));\n\n//the following is executed for every rendered frame\nif (dragging,\n    dx = 3 * (sx - mouse().x); dy = 3 * (sy - mouse().y);,\n    dx = .9*dx; dy = .9*dy;\n);\n\nsx = mouse().x;\nsy = mouse().y;\n\n//the rotation matrix: It is modified either if the user is dragging or time passes\nmat = mat * (\n    (1, 0, 0),\n    (0, cos(dy), -sin(dy)),\n    (0, sin(dy), cos(dy))\n) * (\n    (cos(dx), 0, -sin(dx)),\n    (0, 1, 0),\n    (sin(dx), 0, cos(dx))\n);\n\n\n//configuration for the lights in the scene. A light has a position, a gamma-parameter for its shininess and a color\nlightdirs = apply(getCameraSpaceLightDirections(),mat * #) ++ getSurfaceSpaceLightDirections();\ngamma = getLightGammas();\ncolors = getLightColors();\n\n\n// translucent surface: find all roots from back to front\n// opaque surface: stop after first root has been found\nfindAllRoots = alpha < .99;\n\n\ncolorplot(\n  spolyvalues = apply([-2, 0, 2], v, S(ray(#, v))); //evaluate S along ray\n  spoly = B3 * spolyvalues;                         //interpolate to monomial basis\n  D = (spoly_2 * spoly_2) - 4. * spoly_3 * spoly_1; //discriminant of spoly\n  \n  color = (0., 0., 0., 0.); // background color: fully transparent\n  if (D >= 0, //ray intersects ball\n    color = computeColor(\n      #, \n      (-spoly_2 - re(sqrt(D))) / (2 * spoly_3), //intersection entering the ball\n      (-spoly_2 + re(sqrt(D))) / (2 * spoly_3), //intersection leaving the ball\n      color\n    );              \n  );\n  color //return value: WebGL uses premultiplied alpha by default for RGBA which is already our internal representation!!!\n); //render the scene. # is the pixel coordinate\n\ngrestore();\n\n// loop animation if there is motion (and we are not dragging), otherwise stop\nif(dragging % |(dx,dy)|>.0001, playanimation(), pauseanimation());\n"),mousedown:e("sx = mouse().x;\nsy = mouse().y;\ndragging = sx < .5;\n"),mouseup:e("dragging = false;\n")},animation:{autoplay:!1},use:["CindyGL","symbolic","surfer-js-core-gpu"],ports:[{element:o,transform:[{visibleRect:[-.51,-.51,.51,.51]}]}]});return new Promise((e=>{s.set(a,{onInit:n=>{const i=o.parentElement;if(null===i)throw new Error("Something went wrong during startup of Cinderella applet");new ResizeObserver((()=>{const e=o.width/o.height;a.evokeCS(`aspectRatio = ${e};`)})).observe(o);const t=new l(n,i,o);e(t)}}),a.startup()}))}}var p=l;export{p as default,l as SurferCoreGpu};
//# sourceMappingURL=surfer-core-gpu.mjs.map
