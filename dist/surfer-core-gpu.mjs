function n(n,e,t,i){Object.defineProperty(n,e,{get:t,set:i,enumerable:!0,configurable:!0})}function e(n){return n&&n.__esModule?n.default:n}var t,i={};t=i,Object.defineProperty(t,"__esModule",{value:!0,configurable:!0}),n(i,"default",(function(){return h})),n(i,"SurferCoreGpu",(function(){return d}));CindyJS;function a(n){return new Array(n+1).fill(0).map(((e,t)=>t/n))}function o(n,e){return(function(n,e){return Math.cos((2*n-1)/(2*e)*Math.PI)}(n,e)+1)/2}function r(n){return new Array(n+1).fill(0).map(((n,e)=>e+1)).map((e=>o(e,n+1)))}class s{minDegree;maxDegree;nodeGenerator;constructor(n=s.nodeGeneratorEquidistant(),e=Number.POSITIVE_INFINITY,t=0){this.nodeGenerator=n,this.minDegree=Math.max(0,t),this.maxDegree=Math.max(this.minDegree,e)}getMinDegree(){return this.minDegree}getMaxDegree(){return this.maxDegree}generateNodes(n){const e=Math.max(this.minDegree,Math.min(n,this.maxDegree)),t=this.nodeGenerator(e).map((n=>Math.max(0,Math.min(n,1))));for(t.length=Math.min(t.length);t.length<e+1;)t.push(1);return t}static nodeGeneratorEquidistant(){return a}static nodeGeneratorChebyshev(){return r}}const l=`${e('//initialize some variables\nmat = [\n    [0.3513, -0.4908, -0.7973],\n    [-0.8171, -0.5765, -0.0051],\n    [-0.4571, 0.6533, -0.6036]\n];\nsx = mouse().x;\nsy = mouse().y;\ndragging = false;\nN = 5; // degree of the surface; will be overwritten\nli = []; // nodes for interpolation; will be overwritten\nzoom = 2.2;\na = 0.3;\nalpha = .7;\naspectRatio = 1.0;\nhasTwoSides = true;\n\n//we stand at position mat*(0, 0, -2.2) and watch to (0,0,0).\n//ray(pixel, t) is the point in R^3 that lies at position t the ray behind the pixel at location pixel(vec2)\n//t=0 is corresponds to points within the interesting area near (0,0,0)\nray(pixel, t) := mat * ((t+2.2) * (pixel.x, pixel.y, 1) + (0, 0, -2.2));\n\n//sphere with radius 1 for clipping\nS(r) := (r * r - 1);\n\n//fun is the user defined trivariate polynomial\nfun(x, y, z) := x^2 + 1;\n\n//F takes vec3 instead of 3 variables\nF(p) := (p=p/zoom;fun(p.x, p.y, p.z));\n    \n//casteljau algorithm to evaluate and subdivide polynomials in Bernstein form.\n//poly is a vector containing the coefficients, i.e. p(x) = sum(0..N, i, poly_(i+1) * b_(i,N)(x)) where b_(i,N)(x) = choose(N, i)*x^i*(1-x)^(N-1)\ncasteljau(poly, x) := (\n  regional(alpha, beta);\n  alpha = 1-x;\n  beta = x;\n  forall(0..N, k,\n    repeat(N-k,\n      poly_# = alpha*poly_# + beta*poly_(#+1);\n    );\n  );\n  poly //the bernstein-coefficients of the polynomial in the interval [x,1]\n);\n\n//evaluates a polynomial, represented as vector of coefficients in bernstein-form\neval(poly, x) := casteljau(poly, x)_1;\n\nInfinity = 1e100000;\n\n//this function has to be called whenever fun changes\ninit() := (\n  dx = .05; dy =.02;\n  diff(fun(x,y,z), x, dxF(x,y,z) := #);\n  diff(fun(x,y,z), y, dyF(x,y,z) := #);\n  diff(fun(x,y,z), z, dzF(x,y,z) := #);\n\n    N = degree(fun(x,y,z), x, y, z);\n    if(N == -1, N=Infinity);\n    print("Surface degree: " + text(N));\n    newLi = getInterpolationNodes(N);\n    N = length(newLi) - 1;\n    print("Degree of interpolating polynomial: " + text(N));\n    print("Interpolation nodes: " + text(newLi));\n\n    if(newLi != li,\n      li = newLi;\n      //A is the matrix of the linear map that evaluates a polynomial in bernstein-form at the interpolation nodes\n      A = apply(li, node,\n        //the i-th column contains the values of the (i,N) bernstein polynomial evaluated at the interpolation nodes\n        apply(0..N, i, eval(\n          apply(0..N, if(#==i,1,0)), // e_i = [0,0,0,1,0,0]\n          node //evaluate  b_(i,N)(node)\n        )) \n      );\n      \n      B = (inverse(A)); //B interpolates polynomials (in Bernstein basis), given the values [p(li_1), p(li_2), ...]\n    )\n);\n\n//B3 is a matrix that interpolates quadratic polynomials (in monomial basis), given the values [p(-2), p(0), p(2)]\nB3 = inverse(apply([-2, 0, 2], c, apply(0 .. 2, i, c ^ i))); \n\n//use symbolic differentation function\ndF(p) := (p=p/zoom; (\n    dxF(p.x,p.y,p.z),\n    dyF(p.x,p.y,p.z),\n    dzF(p.x,p.y,p.z)\n));\n\n//update the color color for the pixel at position pixel assuming that the surface has been intersected at ray(pixel, dst)\n//because of the alpha-transparency updatecolor should be called for the intersections with large dst first\n// color is a float[4] representing RGBA with premultiplied alpha\nupdatecolor(pixel, dst, color) := (\n  regional(x, normal, dr);\n  x = ray(pixel, dst); //the intersection point in R^3\n  color = (1 - alpha) * color;\n        \n  normal = dF(x);\n  normal = normal / |normal|;\n\n  if(hasTwoSides == false,\n    dr = ray(pixel,1)-ray(pixel,0);\n    if(normal*dr>0, normal=-normal);\n  );\n\n  colorHit = (0., 0., 0.);\n  forall(1..length(lightdirs),\n    //illuminate if the normal and lightdir point in the same direction\n    illumination = max(0, (lightdirs_# / abs(lightdirs_#)) * normal);\n    colorHit = colorHit + alpha * (illumination ^ gamma_#) * colors_#;\n  );\n  color = color + (colorHit_1, colorHit_2, colorHit_3, alpha);\n);\n\n\nnsign(pixel, a, b) := ( //Descartes rule of sign for the interval (a,b)\n  //obtain the coefficients in bernstein basis of F along the ray in interval (a,b) by interpolation within this interval\n  poly = B * apply(li,\n    F(ray(pixel, a+#*(b-a))) //evaluate F(ray(pixel, ·)) along Chebyshev nodes for (a,b)\n  );\n  //count the number of sign changes\n  ans = 0;\n  //last = poly_1;\n  forall(2..(N+1), k,\n    //if(last == 0, last = poly_k;); this (almost) never happens\n    if(min(poly_(k-1), poly_k) <= 0 & 0 <= max(poly_(k-1), poly_k), //sign switch; avoid products due numerics\n      ans = ans + 1;\n    );\n  );\n  ans //return value   \n);\n\n\n//bisect F(ray(pixel, ·)) in [x0, x1] assuming that F(ray(pixel, x0)) and F(ray(pixel, x1)) have opposite signs\nbisectf(pixel, x0, x1) := (\n    regional(v0, v1, m, vm);\n    v0 = F(ray(pixel, x0));\n    v1 = F(ray(pixel, x1));\n    repeat(11,\n        m = (x0 + x1) / 2; vm = F(ray(pixel, m));\n        if (min(v0,vm) <= 0 & 0 <= max(v0, vm), //sgn(v0)!=sgn(vm); avoid products due numerics\n            (x1 = m; v1 = vm;),\n            (x0 = m; v0 = vm;)\n        );\n    );\n    m //return value   \n);\n\n//id encodes a node in a binary tree using heap-indices\n//1 is root node and node v has children 2*v and 2*v+1\n//computes s=2^depth of a node id: Compute floor(log_2(id));\n//purpose: id corresponds interval [id-s,id+1-s]/s\ngets(id) := (\n  s = 1;\n  repeat(15,\n    if(2*s<=id,\n      s = 2*s;\n    )\n  );\n  s //return value\n);\n\n//determines the next node in the binary tree that would be visited by a regular in DFS\n//if the children of id are not supposed to be visited\n//In interval logic: finds the biggest unvisited interval directly right of the interval of id.\nnext(id) := (\n  id = id+1;\n  //now: remove zeros from right (in binary representation) while(id&1) id=id>>1;\n  repeat(15,\n    if(mod(id,2)==0, \n      id = floor(id/2);\n    )\n  );\n  if(id==1, 0, id) //return value - id 0 means we stop our DFS\n);\n\n//what color should be given to pixel with pixel-coordinate pixel (vec2)\n// color is a float[4] representing RGBA with premultiplied alpha\ncomputeColor(pixel, l, u, color) := (\n  regional(a, b);\n  //traverse binary tree (DFS) using heap-indices\n  //1 is root node and node v has children 2*v and 2*v+1\n  id = 1; \n  //maximum number of steps\n  repeat(min(N*8,80),\n    //id=0 means we are done; do only a DFS-step if we are not finished yet\n    if(id>0,\n      s = gets(id); //s = floor(log_2(id))\n      \n      //the intervals [a,b] are chossen such that (id in binary notation)\n      //id = 1   => [a,b]=[l,u]\n      //id = 10  => [a,b]=[l,(u+l)/2]\n      //id = 101 => [a,b]=[l,(u+3*l)/4]\n      //id = 11  => [a,b]=[(u+l)/2,u]\n      //...\n      if(findAllRoots,(\n        // back to front\n        a = u - (u-l)*((id+1)/s-1);\n        b = u - (u-l)*((id+0)/s-1);\n      ),(\n        // front to back\n        a = l + (u-l)*((id+0)/s-1);\n        b = l + (u-l)*((id+1)/s-1);\n      ));\n\n      //how many sign changes has F(ray(pixel, ·)) in (a,b)?\n      cnt = nsign(pixel, a, b);\n      if(cnt == 1, // in this case we found a root (or it is likely to have a multiple root)\n        //=>colorize and break DFS\n        color = updatecolor(pixel, bisectf(pixel, a, b), color);\n        if(findAllRoots,\n          id = next(id), // break DFS\n          id = 0 // stop searching\n        ),\n      if(cnt == 0, //there is no root\n        id = next(id), //break DFS\n        \n        //otherwise cnt>=2: there are cnt - 2*k roots.\n        id = 2*id;  //visit first child within DFS\n      )\n  );  \n  ));\n  color\n);\n')}; csInitDone();`,p=new Map;CindyJS.registerPlugin(1,"surfer-js-core-gpu",(n=>{const e=n.instance,t=p.get(e);if(void 0===t)throw new Error("Unknown CindyJS instance.");const{onInit:i}=t;n.defineFunction("csInitDone",0,(()=>i(n)))}));class d{api;cdy;element;canvas;algorithm;expression="x^2 - 1";twoSided=!0;alpha=1;zoom=1;parameters={};static Algorithms={PolynomialInterpolation:s};constructor(n,e,t){this.api=n,this.cdy=n.instance,this.element=e,this.canvas=t;const i=s.nodeGeneratorChebyshev();this.algorithm=new s(i,7),this.defineCindyScriptFunctions(),this.setAlgorithm(this.algorithm),this.setExpression(this.expression),this.setTwoSided(this.twoSided),this.setAlpha(this.alpha),this.setZoom(this.zoom),Object.entries(this.parameters).forEach((([n,e])=>this.setParameter(n,e)))}defineCindyScriptFunctions(){this.api.defineFunction("getInterpolationNodes",1,(n=>{const e=this.api.evaluateAndVal(n[0]).value.real;return(n=>({ctype:"list",value:n.map((n=>({ctype:"number",value:{real:n,imag:0}})))}))(this.getAlgorithm().generateNodes(e))}))}getAlgorithm(){return this.algorithm}getExpression(){return this.expression}getTwoSided(){return this.twoSided}getAlpha(){return this.alpha}getZoom(){return this.zoom}getParameter(n){return this.parameters[n]}getParameters(){return{...this.parameters}}getParameterNames(){return Object.keys(this.parameters)}setExpression(n){return this.expression=n,this.cdy.evokeCS(`fun(x,y,z) := (${n}); init();`),this}setTwoSided(n){return this.twoSided=n,this.cdy.evokeCS(`hasTwoSides = (${n?"true":"false"});`),this}setAlpha(n){return this.alpha=n,this.cdy.evokeCS(`alpha = (${n});`),this}setZoom(n){return this.zoom=n,this.cdy.evokeCS(`zoom = (${n});`),this}setParameter(n,e){return this.parameters[n]=e,this.cdy.evokeCS(`${n} = (${e});`),this}setAlgorithm(n){this.algorithm=n,this.cdy.evokeCS("init();")}static async create(n,t=256,i=256){const a=n.ownerDocument.createElement("canvas");a.width=t,a.height=i,n.appendChild(a);const o=CindyJS.newInstance({scripts:{init:l,draw:e("gsave();\nif(aspectRatio > 1.0,scale(1.0/aspectRatio));\n\n//the following is executed for every rendered frame\nif (dragging,\n    dx = 3 * (sx - mouse().x); dy = 3 * (sy - mouse().y);,\n    dx = .9*dx; dy = .9*dy;\n);\n\nsx = mouse().x;\nsy = mouse().y;\n\n//the rotation matrix: It is modified either if the user is dragging or time passes\nmat = mat * (\n    (1, 0, 0),\n    (0, cos(dy), -sin(dy)),\n    (0, sin(dy), cos(dy))\n) * (\n    (cos(dx), 0, -sin(dx)),\n    (0, 1, 0),\n    (sin(dx), 0, cos(dx))\n);\n\n\n//configuration for the lights in the scene. A light has a position, a gamma-parameter for its shininess and a color\nlightdirs = [\n    ray((.0, .0), -100), //enlights parts of the surface which normal points away from the camera\n    ray((.0, .0), -100),\n    ray((.0, .0), 100), //Has an effect, if the normal of the surface points to the camera\n    ray((.0, .0), 100),\n    (-10, 10, -2.),\n    (10, -8, 3.)\n];\n\ngamma = [1, 10, 1, 10, 5, 5];\n\n        \ncolors = [\n    (.3, .5, 1.),\n    (1, 2, 2) / 2,\n    (1., 0.2, 0.1),\n    (2, 2, 1) / 2,\n    .9 * (.7, .8, .3),\n    .9 * (.6, .1, .6)\n];\n\n\n// translucent surface: find all roots from back to front\n// opaque surface: stop after first root has been found\nfindAllRoots = alpha < .99;\n\n\ncolorplot(\n  spolyvalues = apply([-2, 0, 2], v, S(ray(#, v))); //evaluate S along ray\n  spoly = B3 * spolyvalues;                         //interpolate to monomial basis\n  D = (spoly_2 * spoly_2) - 4. * spoly_3 * spoly_1; //discriminant of spoly\n  \n  color = (0., 0., 0., 0.); // background color: fully transparent\n  if (D >= 0, //ray intersects ball\n    color = computeColor(\n      #, \n      (-spoly_2 - re(sqrt(D))) / (2 * spoly_3), //intersection entering the ball\n      (-spoly_2 + re(sqrt(D))) / (2 * spoly_3), //intersection leaving the ball\n      color\n    );              \n  );\n  color //return value: WebGL uses premultiplied alpha by default for RGBA which is already our internal representation!!!\n); //render the scene. # is the pixel coordinate\n\ngrestore();\n\n// loop animation if there is motion (and we are not dragging), otherwise stop\nif(dragging % |(dx,dy)|>.0001, playanimation(), pauseanimation());\n"),mousedown:e("sx = mouse().x;\nsy = mouse().y;\ndragging = sx < .5;\n"),mouseup:e("dragging = false;\n")},animation:{autoplay:!1},use:["CindyGL","symbolic","surfer-js-core-gpu"],ports:[{element:a,transform:[{visibleRect:[-.51,-.51,.51,.51]}]}]});return new Promise((n=>{p.set(o,{onInit:e=>{const t=a.parentElement;if(null===t)throw new Error("Something went wrong during startup of Cinderella applet");new ResizeObserver((()=>{const n=a.width/a.height;o.evokeCS(`aspectRatio = ${n};`)})).observe(a);const i=new d(e,t,a);n(i)}}),o.startup()}))}}var h=d;export{h as default,d as SurferCoreGpu};
//# sourceMappingURL=surfer-core-gpu.mjs.map
