function n(n,e,i,t){Object.defineProperty(n,e,{get:i,set:t,enumerable:!0,configurable:!0})}function e(n){return n&&n.__esModule?n.default:n}var i,t={};i=t,Object.defineProperty(i,"__esModule",{value:!0,configurable:!0}),n(t,"default",(function(){return r})),n(t,"SurferCoreGpu",(function(){return s}));CindyJS;const a=`${e("//initialize some variables\nmat = [\n    [0.3513, -0.4908, -0.7973],\n    [-0.8171, -0.5765, -0.0051],\n    [-0.4571, 0.6533, -0.6036]\n];\nsx = mouse().x;\nsy = mouse().y;\ndragging = false;\nN = 5;\nzoom = 2.2;\na = 0.3;\nalpha = .7;\naspectRatio = 1.0;\n\n//we stand at position mat*(0, 0, -2.2) and watch to (0,0,0).\n//ray(pixel, t) is the point in R^3 that lies at position t the ray behind the pixel at location pixel(vec2)\n//t=0 is corresponds to points within the interesting area near (0,0,0)\nray(pixel, t) := mat * ((t+2.2) * (pixel.x, pixel.y, 1) + (0, 0, -2.2));\n\n//sphere with radius 1 for clipping\nS(r) := (r * r - 1);\n\n//fun is the user defined trivariate polynomial\nfun(x, y, z) := x^2 + 1;\n\n//F takes vec3 instead of 3 variables\nF(p) := (p=p/zoom;fun(p.x, p.y, p.z));\n    \n//casteljau algorithm to evaluate and subdivide polynomials in Bernstein form.\n//poly is a vector containing the coefficients, i.e. p(x) = sum(0..N, i, poly_(i+1) * b_(i,N)(x)) where b_(i,N)(x) = choose(N, i)*x^i*(1-x)^(N-1)\ncasteljau(poly, x) := (\n  regional(alpha, beta);\n  alpha = 1-x;\n  beta = x;\n  forall(0..N, k,\n    repeat(N-k,\n      poly_# = alpha*poly_# + beta*poly_(#+1);\n    );\n  );\n  poly //the bernstein-coefficients of the polynomial in the interval [x,1]\n);\n\n//evaluates a polynomial, represented as vector of coefficients in bernstein-form\neval(poly, x) := casteljau(poly, x)_1;\n\n//this function has to be called whenever fun changes\ninit() := (\n  dx = .05; dy =.02;\n  diff(fun(x,y,z), x, dxF(x,y,z) := #);\n  diff(fun(x,y,z), y, dyF(x,y,z) := #);\n  diff(fun(x,y,z), z, dzF(x,y,z) := #);\n  \n    newN = degree(fun(x,y,z), x, y, z);\n    if(newN==-1, newN=1000);\n    if(newN!=N,\n      N = newN;\n      //The following line is DIRTY, but it makes the application run smooth for high degrees. :-)\n      //Nethertheless, it might cause render errors for high degree surfaces. In fact, only a subset of the surface is rendered.\n      //Adapt limit according to hardware.\n      //values of kind 4*n-1 are good values, as it means to use vectors of length 4*n.\n      N = min(N,7); \n      \n      //N+1 Chebyshev nodes for interval (0, 1)\n      li = apply(1..(N+1), k, (cos((2 * k - 1) / (2 * (N+1)) * pi)+1)/2);\n      \n      //A is the matrix of the linear map that evaluates a polynomial in bernstein-form at the Chebyshev nodes\n      A = apply(li, node,\n        //the i-th column contains the values of the (i,N) bernstein polynomial evaluated at the Chebyshev nodes\n        apply(0..N, i, eval(\n          apply(0..N, if(#==i,1,0)), // e_i = [0,0,0,1,0,0]\n          node //evaluate  b_(i,N)(node)\n        )) \n      );\n      \n      B = (inverse(A)); //B interpolates polynomials (in Bernstein basis), given the values [p(li_1), p(li_2), ...]\n    )\n    \n);\n\n//B3 is a matrix that interpolates quadratic polynomials (in monomial basis), given the values [p(-2), p(0), p(2)]\nB3 = inverse(apply([-2, 0, 2], c, apply(0 .. 2, i, c ^ i))); \n\n//use symbolic differentation function\ndF(p) := (p=p/zoom; (\n    dxF(p.x,p.y,p.z),\n    dyF(p.x,p.y,p.z),\n    dzF(p.x,p.y,p.z)\n));\n\n//update the color color for the pixel at position pixel assuming that the surface has been intersected at ray(pixel, dst)\n//because of the alpha-transparency updatecolor should be called for the intersections with large dst first\n// color is a float[4] representing RGBA with premultiplied alpha\nupdatecolor(pixel, dst, color) := (\n  regional(x, normal);\n  x = ray(pixel, dst); //the intersection point in R^3\n  color = (1 - alpha) * color;\n        \n  normal = dF(x);\n  normal = normal / |normal|;\n\n  colorHit = (0., 0., 0.);\n  forall(1..length(lightdirs),\n    //illuminate if the normal and lightdir point in the same direction\n    illumination = max(0, (lightdirs_# / abs(lightdirs_#)) * normal);\n    colorHit = colorHit + alpha * (illumination ^ gamma_#) * colors_#;\n  );\n  color = color + (colorHit_1, colorHit_2, colorHit_3, alpha);\n);\n\n\nnsign(pixel, a, b) := ( //Descartes rule of sign for the interval (a,b)\n  //obtain the coefficients in bernstein basis of F along the ray in interval (a,b) by interpolation within this interval\n  poly = B * apply(li,\n    F(ray(pixel, a+#*(b-a))) //evaluate F(ray(pixel, ·)) along Chebyshev nodes for (a,b)\n  );\n  //count the number of sign changes\n  ans = 0;\n  //last = poly_1;\n  forall(2..(N+1), k,\n    //if(last == 0, last = poly_k;); this (almost) never happens\n    if(min(poly_(k-1), poly_k) <= 0 & 0 <= max(poly_(k-1), poly_k), //sign switch; avoid products due numerics\n      ans = ans + 1;\n    );\n  );\n  ans //return value   \n);\n\n\n//bisect F(ray(pixel, ·)) in [x0, x1] assuming that F(ray(pixel, x0)) and F(ray(pixel, x1)) have opposite signs\nbisectf(pixel, x0, x1) := (\n    regional(v0, v1, m, vm);\n    v0 = F(ray(pixel, x0));\n    v1 = F(ray(pixel, x1));\n    repeat(11,\n        m = (x0 + x1) / 2; vm = F(ray(pixel, m));\n        if (min(v0,vm) <= 0 & 0 <= max(v0, vm), //sgn(v0)!=sgn(vm); avoid products due numerics\n            (x1 = m; v1 = vm;),\n            (x0 = m; v0 = vm;)\n        );\n    );\n    m //return value   \n);\n\n//id encodes a node in a binary tree using heap-indices\n//1 is root node and node v has children 2*v and 2*v+1\n//computes s=2^depth of a node id: Compute floor(log_2(id));\n//purpose: id corresponds interval [id-s,id+1-s]/s\ngets(id) := (\n  s = 1;\n  repeat(15,\n    if(2*s<=id,\n      s = 2*s;\n    )\n  );\n  s //return value\n);\n\n//determines the next node in the binary tree that would be visited by a regular in DFS\n//if the children of id are not supposed to be visited\n//In interval logic: finds the biggest unvisited interval directly right of the interval of id.\nnext(id) := (\n  id = id+1;\n  //now: remove zeros from right (in binary representation) while(id&1) id=id>>1;\n  repeat(15,\n    if(mod(id,2)==0, \n      id = floor(id/2);\n    )\n  );\n  if(id==1, 0, id) //return value - id 0 means we stop our DFS\n);\n\n//what color should be given to pixel with pixel-coordinate pixel (vec2)\n// color is a float[4] representing RGBA with premultiplied alpha\ncomputeColor(pixel, l, u, color) := (\n  regional(a, b);\n  //traverse binary tree (DFS) using heap-indices\n  //1 is root node and node v has children 2*v and 2*v+1\n  id = 1; \n  //maximum number of steps\n  repeat(min(newN*8,80),\n    //id=0 means we are done; do only a DFS-step if we are not finished yet\n    if(id>0,\n      s = gets(id); //s = floor(log_2(id))\n      \n      //the intervals [a,b] are chossen such that (id in binary notation)\n      //id = 1   => [a,b]=[l,u]\n      //id = 10  => [a,b]=[l,(u+l)/2]\n      //id = 101 => [a,b]=[l,(u+3*l)/4]\n      //id = 11  => [a,b]=[(u+l)/2,u]\n      //...\n      if(findAllRoots,(\n        // back to front\n        a = u - (u-l)*((id+1)/s-1);\n        b = u - (u-l)*((id+0)/s-1);\n      ),(\n        // front to back\n        a = l + (u-l)*((id+0)/s-1);\n        b = l + (u-l)*((id+1)/s-1);\n      ));\n\n      //how many sign changes has F(ray(pixel, ·)) in (a,b)?\n      cnt = nsign(pixel, a, b);\n      if(cnt == 1 % (b-a)<1e-4, //in this case we found a root (or it is likely to have a multiple root)\n        //=>colorize and break DFS\n        color = updatecolor(pixel, bisectf(pixel, a, b), color);\n        if(findAllRoots,\n          id = next(id), // break DFS\n          id = 0 // stop searching\n        ),\n      if(cnt == 0, //there is no root\n        id = next(id), //break DFS\n        \n        //otherwise cnt>=2: there are cnt - 2*k roots.\n        id = 2*id;  //visit first child within DFS\n      )\n  );  \n  ));\n  color\n);\n")}; csInitDone();`,o=new Map;CindyJS.registerPlugin(1,"surfer-js-core-gpu",(n=>{const e=n.instance,i=o.get(e)?.onInit;if(void 0===i)throw new Error("Unknown CindyJS instance.");n.defineFunction("csInitDone",0,(()=>i(e)))}));class s{cdy;element;canvas;expression="x^2 - 1";alpha=1;zoom=1;parameters={};constructor(n,e,i){this.cdy=n,this.element=e,this.canvas=i,this.setExpression(this.expression),this.setAlpha(this.alpha),this.setZoom(this.zoom),Object.entries(this.parameters).forEach((([n,e])=>this.setParameter(n,e)))}getExpression(){return this.expression}getAlpha(){return this.alpha}getZoom(){return this.zoom}getParameter(n){return this.parameters[n]}getParameters(){return{...this.parameters}}getParameterNames(){return Object.keys(this.parameters)}setExpression(n){return this.expression=n,this.cdy.evokeCS(`fun(x,y,z) := (${n}); init();`),this}setAlpha(n){return this.alpha=n,this.cdy.evokeCS(`alpha = (${n});`),this}setZoom(n){return this.zoom=n,this.cdy.evokeCS(`zoom = (${n});`),this}setParameter(n,e){return this.parameters[n]=e,this.cdy.evokeCS(`${n} = (${e});`),this}static async create(n,i=256,t=256){const r=n.ownerDocument.createElement("canvas");r.width=i,r.height=t,n.appendChild(r);const l=CindyJS.newInstance({scripts:{init:a,draw:e("gsave();\nif(aspectRatio > 1.0,scale(1.0/aspectRatio));\n\n//the following is executed for every rendered frame\nif (dragging,\n    dx = 3 * (sx - mouse().x); dy = 3 * (sy - mouse().y);,\n    dx = .9*dx; dy = .9*dy;\n);\n\nsx = mouse().x;\nsy = mouse().y;\n\n//the rotation matrix: It is modified either if the user is dragging or time passes\nmat = mat * (\n    (1, 0, 0),\n    (0, cos(dy), -sin(dy)),\n    (0, sin(dy), cos(dy))\n) * (\n    (cos(dx), 0, -sin(dx)),\n    (0, 1, 0),\n    (sin(dx), 0, cos(dx))\n);\n\n\n//configuration for the lights in the scene. A light has a position, a gamma-parameter for its shininess and a color\nlightdirs = [\n    ray((.0, .0), -100), //enlights parts of the surface which normal points away from the camera\n    ray((.0, .0), -100),\n    ray((.0, .0), 100), //Has an effect, if the normal of the surface points to the camera\n    ray((.0, .0), 100),\n    (-10, 10, -2.),\n    (10, -8, 3.)\n];\n\ngamma = [1, 10, 1, 10, 5, 5];\n\n        \ncolors = [\n    (.3, .5, 1.),\n    (1, 2, 2) / 2,\n    (1., 0.2, 0.1),\n    (2, 2, 1) / 2,\n    .9 * (.7, .8, .3),\n    .9 * (.6, .1, .6)\n];\n\n\n// translucent surface: find all roots from back to front\n// opaque surface: stop after first root has been found\nfindAllRoots = alpha < .99;\n\n\ncolorplot(\n  spolyvalues = apply([-2, 0, 2], v, S(ray(#, v))); //evaluate S along ray\n  spoly = B3 * spolyvalues;                         //interpolate to monomial basis\n  D = (spoly_2 * spoly_2) - 4. * spoly_3 * spoly_1; //discriminant of spoly\n  \n  color = (0., 0., 0., 0.); // background color: fully transparent\n  if (D >= 0, //ray intersects ball\n    color = computeColor(\n      #, \n      (-spoly_2 - re(sqrt(D))) / (2 * spoly_3), //intersection entering the ball\n      (-spoly_2 + re(sqrt(D))) / (2 * spoly_3), //intersection leaving the ball\n      color\n    );              \n  );\n  color //return value: WebGL uses premultiplied alpha by default for RGBA which is already our internal representation!!!\n); //render the scene. # is the pixel coordinate\n\ngrestore();\n"),mousedown:e("sx = mouse().x;\nsy = mouse().y;\ndragging = sx < .5;\n"),mouseup:e("dragging = false;\n")},animation:{autoplay:!0},use:["CindyGL","symbolic","surfer-js-core-gpu"],ports:[{element:r,transform:[{visibleRect:[-.51,-.51,.51,.51]}]}]});return new Promise((n=>{o.set(l,{onInit:()=>{const e=r.parentElement;if(null===e)throw new Error("Something went wrong during startup of Cinderella applet");const i=new s(l,e,r);new ResizeObserver((()=>{const n=r.width/r.height;l.evokeCS(`aspectRatio = ${n};`)})).observe(r),n(i)}}),l.startup()}))}}var r=s;export{r as default,s as SurferCoreGpu};
//# sourceMappingURL=surfer-core-gpu.mjs.map
